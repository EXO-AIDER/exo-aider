classdef SppBluetooth < handle
    %MYBLUETOOTH Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        name
        description
        channel
        
        b        
        message_buffer
        message_buffer_read_idx
        message_buffer_write_idx
        
        signal_buffer = []
        signal_n = 0
        signal_buffer_read_idx = 0
        signal_buffer_write_idx = 0
        signal_name = 'sig'
        signal_low_frequency_names = {}
        signal_high_frequency_names = {}
        signal_low_frequency_ratio = -1
    end
    
    methods
    
        %
        % Contructor and destructor
        %
        function obj = SppBluetooth(name, board_type, description)
            obj.name = name;
            obj.description = description;
            obj.channel = 1;
            obj.connect();
            obj.init(board_type);
        end
        
        function disconnect(obj)
            if ~isempty(obj.b)
                disp(['Disconnecting from "', obj.name, '"...']);
                fclose(obj.b);
                delete(obj.b);
                obj.b = [];
            end
        end
        
        function connect(obj)
            obj.initialize_message_buffer();
            
            disp(['Connecting to "', obj.name, '"...']);
            for old_device = instrfind()
                if strcmpi(old_device.RemoteName, obj.name) && ...
                        old_device.Channel == obj.channel && ...
                        strcmp(old_device.Status, 'open')
                    obj.b = old_device;
                    obj.b.BytesAvailableFcn = @obj.read_callback;
                    if obj.is_connected
                        disp(['Connected to "', obj.name, '" (Using old connection).']);
                       return;
                    else
                        obj.disconnect;
                    end
                end
            end
            
            % Make a new bluetooth connection
            obj.b = Bluetooth(obj.name, obj.channel, 'Timeout',3);           
            obj.b.InputBufferSize = 4096*2;
            obj.b.OutputBufferSize = 4096*2;
            
            % Open connection and configur callbacks
            obj.b.Terminator = 0;
            obj.b.BytesAvailableFcnMode = 'terminator';
            obj.b.BytesAvailableFcn = @obj.read_callback;
            fopen(obj.b);
            assert(obj.is_connected());
            disp(['Connected to "', obj.name, '".']);
        end
        
        function init(obj, board_type)
            if obj.board_type ~= board_type
                warning(['The board type of ', obj.name, ' has been changed. Restart the board for the changes to take effect.']);
                obj.board_type = board_type;
            end
            obj.update_signals_names;
            
        end
        
        function y = is_connected(obj)
            y = ~isnan(obj.ping);
        end
                
        %
        % send, query and flush
        %
        function send(obj, command, numbers)
            if nargin < 3
                data = [uint8(command), 0];
            else
                data = [uint8(command), 0, typecast(single(numbers), 'uint8')];
            end

            encoder = cobss;
            for d = data
                encoder.push(d);
            end
            encoded_message = uint8([encoder.get, 0]);
            fwrite(obj.b, encoded_message);
        end
        
        function q = query(obj, command, numbers)
            q = [];
            if nargin == 3
                obj.send(command, numbers);
            else
                obj.send(command);
            end
            t = tic;
            while toc(t) < obj.b.Timeout 
                if 0 < obj.messages_availiable
                    msg = obj.get_next_message;
                    if startsWith(msg.command, command)
                        q = msg;
                        return
                    end
                end
                pause(0.0001);
            end
        end

        function read_callback(obj, ~, ~)
            try
                encoded_data = uint8(fgets(obj.b));
                if encoded_data(end) ~= 0
                   error('Incorrect termination character!'); 
                end

                % Decode data
                decoder = cobssi;
                for c = encoded_data(1:end-1)
                    decoder.push(c);
                end
                data = decoder.get;
                t_received = posixtime(datetime);

                % Convert to command and numbers
                command_terminator_idx = find(data==0, 1);
                if mod(length(data(command_terminator_idx+1:end)), 4) ~= 0
                   warning(['Got invalid data: [', num2str(data), ']']);
                   return;
                end
                command = char(data(1:command_terminator_idx-1));
                numbers = double(typecast(data(command_terminator_idx+1:end), 'single'));

                % Add to signal or command buffer
                if strcmp(command, obj.signal_name)
                    obj.add_signal_to_buffer(numbers);
                else
                    new_message = Message(command, numbers, t_received);
                    obj.add_message_to_buffer(new_message);
                end
            catch em
                warning(em.getReport);
            end
        end
        
        function flush(obj)
           obj.message_buffer_read_idx = 0;
           obj.message_buffer_write_idx = 0;
           obj.signal_buffer = obj.signal_buffer * nan;
           obj.signal_buffer_write_idx = 0;
           obj.signal_n = 0;
        end
        
        %
        % message fifo buffer initialization, add and get
        %
        function initialize_message_buffer(obj, buffer_size)
           if nargin == 1
              buffer_size = 1000; 
           end
           obj.message_buffer = repmat(Message(), 1, buffer_size);
           obj.flush;
        end

        function x = messages_availiable(obj)
            x = obj.message_buffer_write_idx - obj.message_buffer_read_idx;
        end
        
        function add_message_to_buffer(obj, message)
            n = length(obj.message_buffer);
            idx = 1 + mod(obj.message_buffer_write_idx, n);
            
            obj.message_buffer(idx) = message;
            
            obj.message_buffer_write_idx = obj.message_buffer_write_idx + 1;
            if obj.message_buffer_read_idx + n < obj.message_buffer_write_idx
                %warning('Buffer overflow!');
                obj.message_buffer_read_idx = obj.message_buffer_write_idx - n;
            end
        end
        
        function message = get_next_message(obj)
            n = length(obj.message_buffer);
            idx = 1 + mod(obj.message_buffer_read_idx, n);

            if obj.message_buffer_read_idx >= obj.message_buffer_write_idx
               error('No availiable messages!');
            end
            message = obj.message_buffer(idx);
            
            obj.message_buffer_read_idx = obj.message_buffer_read_idx + 1;
        end
        
        %
        % signal fifo buffer initialization, add and get
        %
        function initialize_signal_buffer(obj, signal_name, buffer_size, ...
                signal_low_frequency_length, signal_high_frequency_length, ...
                signal_low_frequency_ratio)
           if nargin == 1
              buffer_size = 1000; 
           end
           obj.signal_name = signal_name;
           obj.signal_low_frequency_length = signal_low_frequency_length;
           obj.signal_high_frequency_length = signal_high_frequency_length;
           obj.signal_buffer = zeros(buffer_size, signal_low_frequency_length + signal_high_frequency_length) * nan;
           obj.signal_low_frequency_ratio = signal_low_frequency_ratio;
           obj.flush;
        end
        
        function add_signal_to_buffer(obj, numbers)
            n = size(obj.signal_buffer, 1);
            
            high_frequency_samples = obj.signal_low_frequency_ratio;
            expected_numbers_length = obj.signal_low_frequency_length + obj.signal_high_frequency_length * high_frequency_samples;
            if size(numbers,1) ~= 1 || size(numbers, 2) ~= expected_numbers_length
               error('Incorrect number of signals!'); 
            end
            samples = max([high_frequency_samples, 1]);
            low_frequency_numbers = numbers(1:obj.signal_low_frequency_length);
            high_frequency_numbers = numbers(obj.signal_low_frequency_length+1:end);
            
            if 0 < high_frequency_samples
                augmented_numbers = ...
                    [repmat(low_frequency_numbers, high_frequency_samples, 1), ...
                     reshape(high_frequency_numbers, [], high_frequency_samples)'];
            else
                augmented_numbers = repmat(low_frequency_numbers, high_frequency_samples, 1);
            end
            
            idx = 1 + mod(obj.signal_buffer_write_idx + (0:samples-1), n);
            obj.signal_buffer(idx, :) = augmented_numbers;
            
            obj.signal_buffer_write_idx = obj.signal_buffer_write_idx + samples;
            obj.signal_n = obj.signal_n + 1;
        end
        
        function signal = get_signals(obj, sample_idx, signal_idx)
            n = size(obj.signal_buffer, 1);
            min_sample_idx = max([obj.signal_buffer_write_idx - n + 1, 1]);
            max_sample_idx = obj.signal_buffer_write_idx;            
            min_signal_idx = 1;
            max_signal_idx = obj.signal_low_frequency_length+obj.signal_high_frequency_length;
            if nargin < 3 || isempty(signal_idx)
               signal_idx = 1:obj.signal_low_frequency_length+obj.signal_high_frequency_length; 
            end

            if any(sample_idx<min_sample_idx) || any(max_sample_idx < sample_idx)
                error('Sample index out of bounds!');
            end
            if any(signal_idx<min_signal_idx) || any(max_signal_idx < signal_idx)
                error('Signal index out of bounds!');
            end
            
            idx = 1 + mod(sample_idx-1, n);
            signal = obj.signal_buffer(idx, signal_idx);
        end
        
        function signal = get_low_frequency_signals(obj, sample_idx, signal_idx)
            if nargin < 3 || isempty(signal_idx)
               signal_idx = 1:obj.signal_low_frequency_length+obj.signal_high_frequency_length; 
            end
            ratio = obj.signal_low_frequency_ratio;
            signal = obj.get_signals(1 + (sample_idx - 1) * ratio, signal_idx);
        end
    end
    
    %
    % Remote getters, setters and commands
    %
    properties
        board_type
        sample_frequency       
        send_signals_ratio
        send_signals
        u
        low_frequency_signal_names
        high_frequency_signal_names
    end
    properties (Constant)
        board_type_get_cmd = 'get_board_type'
        board_type_set_cmd = 'set_board_type'
        sample_frequency_get_cmd = 'get_sample_frequency'
        sample_frequency_set_cmd = 'set_sample_frequency'
        send_signals_ratio_get_cmd = 'get_send_signals_ratio'
        send_signals_ratio_set_cmd = 'set_send_signals_ratio'
        send_signals_get_cmd = 'get_send_signals'
        send_signals_set_cmd = 'set_send_signals'
        ping_cmd = 'ping'
        lf_signal_names_get_cmd = 'get_lf_signal_names'
        hf_signal_names_get_cmd = 'get_hf_signal_names'
    end
    methods
        % Remote getters and setters
        function set.board_type(obj, val)
           obj.send(obj.board_type_set_cmd, val);
        end
        function val = get.board_type(obj)
           msg = obj.query(obj.board_type_get_cmd);
           val = msg.numbers(1);
        end
        
        function set.sample_frequency(obj, val)
           obj.send(obj.sample_frequency_set_cmd, val);
        end
        function val = get.sample_frequency(obj)
           msg = obj.query(obj.sample_frequency_get_cmd);
           val = msg.numbers(1);
        end
        
        function set.send_signals_ratio(obj, val)
           obj.send(obj.send_signals_ratio_set_cmd, val);
        end
        function val = get.send_signals_ratio(obj)
           msg = obj.query(obj.send_signals_ratio_get_cmd);
           val = msg.numbers(1);
        end
        
        function set.send_signals(obj, val)
           obj.send(obj.send_signals_set_cmd, val);
        end
        function val = get.send_signals(obj)
           msg = obj.query(obj.send_signals_get_cmd);
           val =  msg.numbers(1);
        end
        
        % Remote commands
        function p = ping(obj)
           time_start = posixtime(datetime);
           q = obj.query(obj.ping_cmd);
           if isempty(q)
              p = nan;
              return
           end
           p = (q.time_received - time_start)/2;
        end
        function update_signals_names(obj)
            msg = spp.query(obj.lf_signal_names_get_cmd);             
            tokens = strsplit(msg.command, ':'); 
            obj.signal_low_frequency_names = tokens(2:end);
            
            msg = spp.query(obj.hf_signal_names_get_cmd);
            tokens = strsplit(msg.command, ':'); 
            obj.signal_high_frequency_names = tokens(2:end);
        end
    end
    
    %
    % Helper commands
    %
    methods
        function [mean_latancy, std_latancy, latancy_arr] = estimate_latancy(obj, num_times)
            if nargin < 2
                num_times = 20;
            end
            latancy_arr = zeros(1, num_times);
            
            for i = 1:num_times
                latancy_arr(i) = (msg.time_received - t_start)/2;
                pause(2 * latancy_arr(i));
            end
            mean_latancy = mean(latancy_arr);
            std_latancy = std(latancy_arr);
            
            if nargout == 0
               disp(['Latancy analysis of ' num2str(num_times) ' experiments.']); 
               disp([' * mean: ' num2str(mean_latancy*1e3), ' ms']);
               disp([' * std:  ' num2str(std_latancy*1e3), ' ms']);
            end
        end    
    end
end

